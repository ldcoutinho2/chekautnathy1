
                });
            }
        }

        // Event Listeners
        acceptCallBtn.addEventListener('click', startCall);
        declineCallBtn.addEventListener('click', endCall);
        endCallBtn.addEventListener('click', endCall);
        newCallBtn.addEventListener('click', () => {
            window.location.href = "https://pay.meusite.co/pagar-chamada";
        });
        micBtn.addEventListener('click', toggleMicrophone);
        videoBtn.addEventListener('click', toggleVideo);

        // Proteção contra download
        document.addEventListener('keydown', function(e) {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && e.key === 'I') || 
                (e.ctrlKey && e.shiftKey && e.key === 'J') || 
                (e.ctrlKey && e.key === 'U')) {
                e.preventDefault();
            }
        });

        // Desabilitar menu de contexto
        document.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            return false;
        });

        // Proteção contra captura de tela e força reprodução
        remoteVideo.addEventListener('pause', function(e) {
            if (!e.target.ended) {
                forceVideoPlay(e.target);
            }
        });

        // Force play on any user interaction
        document.addEventListener('touchstart', function() {
            if (remoteVideo.paused && !remoteVideo.ended && remoteVideo.src) {
                forceVideoPlay(remoteVideo);
            }
        }, { once: false });

        document.addEventListener('click', function() {
            if (remoteVideo.paused && !remoteVideo.ended && remoteVideo.src) {
                forceVideoPlay(remoteVideo);
            }
        }, { once: false });

        // Initialize the view based on cache
        checkCallStatus();

        // Simulate getting user camera for local video (always shows loading)
        function getLocalVideo() {
            cameraLoading.classList.remove('hidden');
            localVideo.classList.add('hidden');
            
            // Keep the loading spinner visible indefinitely (no error notification)
            // The loading spinner will remain visible to simulate camera connection attempt
        }

        // Start the call
        function startCall() {
            stopRingtone();
            
            incomingCallView.classList.add('hidden');
            connectingView.classList.remove('hidden');
            
            setTimeout(() => {
                connectingView.classList.add('hidden');
                activeCallView.classList.remove('hidden');
                
                // Configure video for iOS compatibility using CONFIG
                remoteVideo.src = CONFIG.videoUrl;
                remoteVideo.loop = false;
                remoteVideo.muted = true; // Start muted
                remoteVideo.controls = false;
                remoteVideo.setAttribute('playsinline', '');
                remoteVideo.setAttribute('webkit-playsinline', '');
                remoteVideo.setAttribute('disablePictureInPicture', '');
                
                // Force video to load and play
                remoteVideo.load();
                
                // Multiple attempts to ensure video plays
                setTimeout(() => {
                    forceVideoPlay(remoteVideo);
                }, 100);
                
                setTimeout(() => {
                    forceVideoPlay(remoteVideo);
                }, 500);
                
                setTimeout(() => {
                    forceVideoPlay(remoteVideo);
                }, 1000);
                
                // Always show loading for local video
                getLocalVideo();
                
                startTimer();
                
                setTimeout(endCall, CONFIG.callDurationSeconds * 1000);
                
                // Continuous check to ensure video keeps playing
                const checkPlaying = setInterval(() => {
                    if (remoteVideo.paused && !remoteVideo.ended && remoteVideo.src) {
                        forceVideoPlay(remoteVideo);
                    }
                }, 500);
                
                remoteVideo.addEventListener('ended', () => {
                    clearInterval(checkPlaying);
                });
                
                // Additional event listeners for iOS
                remoteVideo.addEventListener('loadeddata', () => {
                    forceVideoPlay(remoteVideo);
                });
                
                remoteVideo.addEventListener('canplay', () => {
                    forceVideoPlay(remoteVideo);
                });
                
            }, 2000);
        }

        // Start call timer
        function startTimer() {
            callDuration = 0;
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                callDuration++;
                updateTimerDisplay();
            }, 1000);
        }

        // Update timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(callDuration / 60).toString().padStart(2, '0');
            const seconds = (callDuration % 60).toString().padStart(2, '0');
            callTimer.textContent = `${minutes}:${seconds}`;
        }

        // End the call
        function endCall() {
            stopRingtone();
            clearInterval(timerInterval);
            
            const actualCallDuration = Math.min(callDuration, CONFIG.callDurationSeconds);
            localStorage.setItem(CONFIG.cacheKeys.callDuration, actualCallDuration.toString());
            
            remoteVideo.pause();
            remoteVideo.currentTime = 0;
            remoteVideo.removeAttribute('src');
            remoteVideo.load();
            
            localVideo.pause();
            localVideo.currentTime = 0;
            localVideo.removeAttribute('src');
            localVideo.load();
            
            blackScreen.classList.remove('hidden');
            
            setTimeout(() => {
                activeCallView.classList.add('hidden');
                incomingCallView.classList.add('hidden');
                connectingView.classList.add('hidden');
                callEndedView.classList.remove('hidden');
                
                const minutes = Math.floor(actualCallDuration / 60).toString().padStart(2, '0');
                const seconds = (actualCallDuration % 60).toString().padStart(2, '0');
                callDurationDisplay.textContent = `Duração: ${minutes}:${seconds}`;
                
                localStorage.setItem(CONFIG.cacheKeys.callCompleted, 'true');
                
                setTimeout(() => {
                    blackScreen.classList.add('hidden');
                }, 500);
            }, 500);
        }
    </script>
</body>
</html>
